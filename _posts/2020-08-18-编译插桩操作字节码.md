---
layout: post
title: '编译插桩操作字节码'
date: 2020-08-18
author: qzhuorui
color: rgb(255,210,32)
tags: JVM/ART
---



# 编译插桩操作字节码

首先举个例子，加入有一个需求：

>  记录每一个页面的打开和关闭事件，并通过各种DataTracking的框架上传到服务器，用来日后做数据分析

我们一般会使用，在每个Activity的onCreate和onDestroy方法中，分别添加页面打开和页面关闭的逻辑。常见做法有两种，如下：

1. 修改项目每个Activity，这样显然非常捞而且容易遗漏
2. 在BaseActivity中进行修改，这样能高级一点，也是常用的，但是有一点，这样对于第三方依赖库中的界面无能为力 = =！

这种环境下，有一种更优雅的方法： **编译插桩**

### 编译插桩是啥

从名字来看，就是在代码**编译期间修改已有的代码或生成新的代码** 。 我们项目中经常用到的Dagger，ButterKnife甚至Kotlin语言，都用到了编译插桩（Kotlin想学没时间啊，一定要了解的）

首先看下Android项目中.java文件的编译过程

![1](/screenshot/编译插桩操作字节码/1.png)

从上图可以看出，我们可以在1，2两处对代码进行改造

1. 在.java文件编译成.class文件时，APT，AndroidAnnotation等就是在此触发代码生成
2. 在.class文件进一步优化成.dex文件时，也就是直接操作字节码文件，这也是主要要了解的。这种方式功能强大，应用场景更广，但需要对字节码有一定理解

我们主要了解第2种方式，用一张图来描述如下过程，其中红色虚框包含了此次学习的内容。

![2](/screenshot/编译插桩操作字节码/2.png)

一般使用编译插桩实现如下几个功能：

- 日志埋点
- 性能控制
- 动态权限控制
- 业务逻辑跳转时，校验是否已经登录
- 代码调试

## 插桩工具介绍

目前主要流行两种实现编译插桩的方式：

### AspectJ

优点是成熟稳定，使用人不需要对字节码文件有深入理解

### ASM

通过ASM可以修改现有的字节码文件，也可以动态生成字节码文件，并且它是一款完全以字节码层面来操纵字节码并分析字节码的框架。

我们这次就使用ASM来实现简单的编译插桩效果，通过插桩实现我们上面说的需求，在每一个Activity打开时输出相应的log日志

## 实现思路

过程主要包含2步：

#### 1.遍历项目中的所有.class文件

如何**找到项目中编译生成的所有.class文件** ，是需要解决的第一个问题。众所周知AS使用Gradle编译项目中的.java文件，并且从Gradle1.5.0之后，我们可以**自定义Transform** ，来**获取所有.class文件引用** 。但是**Transform的使用需要依赖Gradle Plugin** 。

所以第一步需要创建一个单独的Gradle Plugin，并在Gradle Plugin中使用自定义Transform找出所有的.class文件。

#### 2.遍历到目标.class文件（Activity）之后，通过ASM动态注入需要被插入的字节码

如果第一步顺利，我们可以找到所有的.class文件。接下来就需要过滤出目标Activity文件，并在目标Activity文件的onCreate方法中，通过ASM插入相应的log日志字节码

## 具体实现

### 1.创建ASMLifeCycleDemo项目

![3](/screenshot/编译插桩操作字节码/3.png)

### 2.创建自定义Gradle插件

首先在ASMLifeCycleDemo项目中创建一个新的module，并选择Android Library类型，命名为asm_lifecycle_plugin。

将asm_lifecycle_plugin module中除了build.gradle和main文件夹之外的所有内容都删除。然后在main目录下分别创建groovy和java目录的  

![4](/screenshot/编译插桩操作字节码/4.png)

因为Gradle插件时使用groovy语言编写的，所以需要新建一个groovy目录，用来存放插件相关的.groovy类。但ASM是Java层面的框架，所以在Java目录里存放ASM相关的类。

然后在groovy中创建目录对应目录，并在此目录中创建类LifeCyclePlugin.groovy文件。在LifeCyclePlugin中重写apply方法，实现插件逻辑，这里只打印log日志。

![5](/screenshot/编译插桩操作字节码/5.png)

可以看出LifeCyclePlugin实现了gradle api中的Plugin接口。当我们在app module的build.gradle文件中使用此插件时，其LifeCyclePlugin的apply方法会被自动调用。

接下来将asm_lifecycle_plugin module的build.gradle中内容都删除，改为如下内容：

![6](/screenshot/编译插桩操作字节码/6.png)

group和version都需要在app module引入此插件时使用

所有的插件都需要被部署到maven库中，我们可以选择部署到远程或本地。这里demo只部署到本地目录中。具体地址通过repository属性配置，如图我们只是将其配置在项目根目录下的asm_lifecycle_repo目录下

最后一步，创建properties文件

在plugin/src/main目录下新建目录resource/META-INF/gradle-plugins，然后在此目录下新建一个文件，这个文件名就是我们自定义插件的名称，我们会在app module中使用到此名称

在.properties文件中，需要指定我们自定义的插件类名，如下：

![7](/screenshot/编译插桩操作字节码/7.png)

至此，自定义Gradle插件就已经写完了，现在可以在AS右边栏找到Gradle中点击uploadArchives，执行plugin的部署任务：

![8](/screenshot/编译插桩操作字节码/8.png)

可以看到构建成功之后，在Project的根目录下将会出现一个repo目录，里面存放的就是我们的插件目标文件。

### 3.测试asm_lifecycle_plugin





