---
layout: post
title: ' Java知识点总结'
date: 2021-01-06
author: qzhuorui
color: rgb(154,133,255)
tags: 碎片总结

---



> 总结常见的Java碎片化知识点，便于日后记忆翻阅



# Java基础知识整理

## JVM：

1. 什么情况下会发生栈内存溢出？StackOverFlow 与 OOM 的区别？分别发生在什么时候？
   1. 虚拟机栈区域有两个异常：
      1. StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出
      2. OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出
   2. 递归太深；数组声明太大（方法区），创建对象太多（堆），创建线程太多（栈）
2. 如果让你写一段栈溢出的代码你会什么写，一个栈大概有多大，为什么？每个线程都有这样大小的一个栈吗？
   1. 无限递归
   2. -Xss分配大小，JDK1.5+默认为1M
   3. 栈内存是线程私有空间，决定方法调用深度，每个线程都有一个独立的可配置大小的栈，一个函数内的所有函数使用的空间都依赖这个栈，太多变量参数可能导致溢出
   4. 不要在函数内部定义过大局部变量，不要将过大的结构体通过参数传递，注意递归
3. JVM 栈中存储的是什么，堆存储的是什么？
   1. 栈是线程独有，在栈中每个方法对应一个栈帧，栈帧中有局部变量表，引用等数据
   2. 堆是公用区域，非线程独有。存储对象。
4. Java 对象会不会分配到栈中？
   1. 不会
   2. C++中有，会随着方法的退出而销毁，减轻GC开销
   3. Java逃逸分析（主要分析对象的作用域），判断一个对象会不会逃逸到方法或线程之外。
5. JVM，DVM，ART的区别
   1. JVM是Java虚拟机，运行的是class文件
   2. DVM可以说是Android虚拟机（实际为认证），.class——.odex，65535问题，所以安装时需要合包
   3. ART还会优化为.oat文件，不用合包
6. PathClassLoader 与 DexClassLoader 的区别是什么？
   1. PathClassLoader只支持直接操作.dex，或已安装APK（已安装的在cache中存在dex）
   2. DexClassLoader支持.apk，.jar，.dex且会在指定classPath释放dex
7. 什么是双亲委托机制，为什么需要双亲委托机制？
   1. 类加载：把class字节码文件从硬盘中加载到内存，类加载器就是完成加载的工具
   2. 双亲委派：当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器，只有父类加载器在自己搜索范围内找不到指定类时，子类加载器才会自己来（从下往上找类是否加载，从上往下加载类）
   3. 用处：1.防止重复加载，每次加载都向上询问 2.保证核心类不被篡改，即使被篡改加载的类也不同
   4. 两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等，基础类无论是被谁加载最终都会往上传递由指定的类加载器加载，保证了内存中基础类只存在一种，Object
8. 描述 JVM 类加载过程
   1. 加载、验证、准备、解析、初始化
9. String 对象主要存储在哪块区域
   1. 1.8后heap分成两块区域
   2. string是在heap的字符串常量池中，唯一存在
   3. string对象是heap另一区域，存储的是对象
10. JVM运行时数据区
    1. 公用：方法区，堆
    2. 线程私有：虚拟机栈，本地方法栈，程序计数器
11. JVM创建对象的过程/请描述 new 一个对象的流程
    1. 编译：.java -- .class
    2. 加载：.class经过加载，会把类相关信息加载到JVM内存中
    3. 链接：对静态变量的值进行默认赋值
    4. 初始化：对静态变量进行真正的赋值；收集类静态代码块内容并执行
    5. 对象创建：~~~
12. 深拷贝和浅拷贝
    1. 浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，只复制对象空间而不复制资源
    2. 深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，新建了空间
    3. java数据类型：因为有值传递和引用传递（基础数据类型和引用类型），才从而出现的深浅拷贝
    4. 浅拷贝和对象拷贝：
       1. 浅拷贝得到是两个不同对象，两个对象中基础数据类型修改互不影响，引用类型是有影响的
       2. 对象拷贝没有生成新对象，两者对象地址一样，修改任何值都相互影响
    5. 深拷贝新建了空间，无相互影响，对于有多层对象的，每个对象都需要实现 `Cloneable` 并重写 `clone()` 方法，进而实现了对象的串行层层拷贝
13. jvm中，直接内存是什么
    1. 直接内存也叫对外内存，在Java堆外，直接向系统申请的内存，使用NIO native函数来分配和操作的内存区域，不受JVM管控
    2. 对于频繁io操作，用直接内存可以减少堆的内存外存来回复制的操作
    3. 对于生命周期较长的对象，不需要频繁gc，可以用直接内存
    4. 因为jvm申请的内存有限，可以通过外存来扩大内存



## GC：

1. 介绍下分代回收策略
   1. 分代的思想是：对新创建的对象会在新生代中分配内存，此区域对象声明周期比较短。如果经过多次回收仍活下来，就转到老年代。
2. GC 收集算法有哪些？它们的特点是什么？
   1. 标记清除算法，简单但产生碎片
   2. 标记复制算法，无碎片，可用内存缩为一半，对象存活率高时会频繁复制
   3. 标记压缩算法，无碎片也不缩小内存，压缩还是要移动对象，效率低
3. 如何判断一个对象是否被回收，有哪些 GC 算法，实际虚拟机使用最多的是什么 GC 算法？
   1. GCRoots作为起始点，可达性分析算法（判断引用链），标记对象
   2. GCRoots：
      1. 虚拟机栈（局部变量表）中引用的对象
      2. 方法区中静态引用指向的对象
      3. 仍处于活跃状态中的线程对象
      4. Native中JNI引用的对象
4. 新生代和老年代用的垃圾回收策略，新生代和老年代都用什么算法
   1. 新生代：对象朝生夕死存活率低，回收率高。复制算法。
      1. 又分为Eden，S0，S1。8：1：1划分。S0，S1反复15次（默认）就转移到老年代。
   2. 老年代：声明周期长，不需要过多复制操作。标记压缩算法。还有个card table记录了老年代对新生代的引用。
5. 你觉得可达性分析用什么数据结构比较好（垃圾回收的延伸知识）
   1. 图

## Java：

1. Java 中有几种引用关系，它们的区别是什么

   1. 强引用，软引用，弱引用，虚引用

2. String，Stringbuffer，StringBuilder 的区别是什么？在进行字符串操作时的效率；String 在内存中是如何创建的？

   1. String：final，每次操作需要生成新的string对象。过程需要在堆中开辟内存，结果也要开辟内存，两个字符串开辟三次。
      1. str = "hello"，str+"world"，"world"开辟一次，新生成的"helloworld"也要开辟
   2. stringbuffer：可变，线程安全
   3. stringbuilder：可变，非线程安全
   4. heap分成两部分：字符串常量池，堆。string a="a";会在字符串常量池中寻找已有则返回引用，无则创建；new string("a")；只是在堆中创建一个新string对象，不管是否存在，也不会添加到常量池中。但可以调用intern()加进去。

3. String 为什么是不可变的？String为什么设计成final的？

   1. 安全。引用问题，是否可修改。

   ```java
   appendStr(string s){
   	s+="bbb";
   	return s;
   }
   main(string[] args){
   	string s = new string("aaa");
   	stirng ns = appendStr(s);
   	println(s.toString());
   }
   //非基本类型，所以是引用传递。此时如果string非final则s.toString就是aaabbb了。而实际上我们并不想改变s的值，指向sb.toString是aabbb。所以string用final修饰了
   ```

   2. 线程安全，不可变对象不能背写，所以线程安全

4. final 、finally、finalize 区别

   1. 只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。会撤销之前的return语句，继续执行最后的finally块中的代码
   2. finalize对象被回收时调用，可以释放资源，但是调用后不会立刻GC，而且只会调用一次，所以调用了又不回收，最后回收时又不调用了，此时可能会出现问题

5. 抽象类和接口的区别

   1. 抽象类中可以有普通成员变量，接口中不行
   2. 抽象类可以包含非抽象方法，接口都是抽象方法
   3. 一个类可以实现多个接口，但只能继承一个抽象类

6. 重载和重写的区别

   1. 答：重写（两同、两小、一大），重载（方法名一致，形参列表不同）

7. 什么是值传递和引用传递，Java 是值传递还是引用传递？

   1. 基本类型，引用类型
   2. =赋值和改变自身的方法。注意string是final，虽然引用类型但是还是不变

   ```java
   作者：Intopass
   链接：https://www.zhihu.com/question/31203609/answer/50992895
   来源：知乎
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   
   第一个例子：基本类型
   void foo(int value) {
       value = 100;
   }
   foo(num); // num 没有被改变
   
   第二个例子：没有提供改变自身方法的引用类型
   void foo(String text) {
       text = "windows";
   }
   foo(str); // str 也没有被改变
   
   第三个例子：提供了改变自身方法的引用类型
   StringBuilder sb = new StringBuilder("iphone");
   void foo(StringBuilder builder) {
       builder.append("4");
   }
   foo(sb); // sb 被改变了，变成了"iphone4"。
   
   第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。
   StringBuilder sb = new StringBuilder("iphone");
   void foo(StringBuilder builder) {
       builder = new StringBuilder("ipad");
   }
   foo(sb); // sb 没有被改变，还是 "iphone"
   ```

   

8. String s = new String(“”);创建了几个对象?

   1. 堆中创建一个对象。当调用Intern()时，会在字符串常量区中创建一个。

9. Java 里 equals和== 区别

   1. equals比较内容，当对象时需要重写，否则默认走到了==
   2. ==比较地址

10. try-catch-finally，try 里有 return，finally 还执行么？

    1. 在try中没有异常的情况下try、catch、finally的执行顺序 try --- finally
    2. 如果try中有异常，执行顺序是try --- catch --- finally
    3. 如果try中没有异常并且try中有return这时候正常执行顺序是try ---- finally --- return，返回return中已准备好的值
    4. 如果try中有异常并且try中有return这时候正常执行顺序是try----catch---finally--- return
    5. 只有在trt{}块中包含遇到**System.exit（0）**。之类的导致Java虚拟机直接退出的语句才会不执行

11. Excption 与 Error 区别

    1. 都继承自Throwable
    2. Excption：中断。是程序正常运行中可以预料额意外情况，可能并应该被捕获进行相应处理
       1. 可检查：编译期
       2. 不可检查：即运行时异常空指针，下标越界等
    3. Error：背离。是正常情况下不太可能出现的问题，不便于也不需被捕获，如果OOM。

12. Static class 与 non static class 的区别

    1. 内部静态类，不持有外部类的引用。static Handler
    2. 静态类只能访问外部类的静态成员，不能访问非静态

13. 动态代理是什么？如何实现？动态代理的方法怎么初始化的？

    1. 

14. CGLIB 动态代理

15. 说说反射的应用场景，哪些框架，原理是什么？

16. Java 泛型的特点与优缺点，泛型擦除是怎么回事？

17. 泛型 super 和 extends 的区别。a.说法 2：Java 的泛型，<? super T> 和 <? extends T> 的区别

18. 为什么 IO 是耗时操作？为什么Java使用JNI调用C++方法，速度快？

19. 内存泄露的场景

20. final 关键字的作用，final 在多线程并发条件下的作用

21. 面向对象的特点

22. 继承时候可以去访问私有对象么

23. java 语言中，不加任何限定符表示的是什么

24. 接口不加限定词是什么状态，是包可见的么

25. final 和 finally 的差别，finally 中一般会做什么事情

26. java 在 1.7 或者 1.8 之后，还需要 finally 这个东西么，有没有其他的语法可以替代掉么，换个说法是：“1.8以后，try语句还有其他写法么？”

27. 四种类型强制转换

28. 数组和链表的区别

29. static的静态方法能不能被继承

30. final修饰不同类，方法，基本数据类型的区别，修饰string类以后会怎么样

