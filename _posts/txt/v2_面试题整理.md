# JAVA

1. GC算法，垃圾搜集算法有哪些
2. GC（GC回收时机，如何GC回收，标记了的立刻会被回收吗）
3. 你怎么判断对象是gc roots对象
4. 垃圾回收机制，有什么代，用什么策略
5. java finalize用来干啥,gc都系统做了，为什么还有finalize这个方法
6. JVM内存模型？性能调优？
7. 内部类相比继承有什么优势？
8. static
9. 反射机制
10. 四大引用，java引用类型（强 软 弱 虚）
11. jvm内存区域
12. JVM的gc什么机制（GC roots可达性）
13. 内部类能访问外部的变量和方法吗
14. 多态
15. classloader类加载机制，双亲委派模型
16. 内部类和静态内部类和匿名内部类
17. 单例和静态变量，静态方法的区别
18. 比较两个对象怎么比较，equals，== ；==和equals区别，重写equals怎么写,hashcode作用
19. 单例模式

# Android

1. ThreadLocal 原理
   1. 是一个线程内部的存储类，可以在指定线程内存储数据，也只有在指定线程可以得到存的数据，其中的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table
   2. 每个线程持有一个ThreadLocalMap对象。每个新的线程都会实例化一个ThreadLocalMap并赋值给成员变量threadLocals。每个线程都对应一个ThreadLocalMap，而ThreadLocalMap负责维护和访问ThreadLocalMap
   3. 也就是说ThreadLocal类型的本地变量是存放在具体的线程空间上，其本省相当于一个装载本地变量的工具壳，通过set方法将value添加到调用线程的threadlocals中，当调用线程调用get方法时能够从它的threadLocals中取出变量。本地变量不用了要remove，因为如果线程一直不消亡，可能会OOM
2. 四大组件
3. Activity的加载模式 standard，singleTop，singleTask，singleInstance
4. Activity，Fragment（fragment添加的方法，生命周期），Fragment比Activity的优点
   1. 优点：
      1. 模块化：不必把所有代码放入Activity中，而是写在各自的Fragment中
      2. 可重用：多个Activity可以重用一个Fragment
   2. 生命周期：运行，暂停，停止，销毁
      1. onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，getArguments获取参数
      2. onCreate()：Fragment被创建时调用
      3. onActivityCreated()：当Activity完成onCreate()时调用
      4. onStart()：当Fragment可见时调用
      5. onResume()：当Fragment可见且可交互时调用
      6. onPause()：当Fragment不可交互但可见时调用
      7. onStop()：当Fragment不可见时调用
      8. onDestoryView()：当Fragment的UI从视图结构中移除时调用
      9. onDrstory()：销毁Fragment时调用
      10. onDetach()：当Fragment和Activity解除关联时调用
   3. 添加方式
      1. 静态加载：布局的方式加载，一旦添加就不能在运行时删除
      2. 动态加载：获取FragmentManager对象，通过FragmentManager再获取FragmentTransmit对象，开启事务，调用add()或replace()方法加载Fragment，最后commit()提交事务
   4. 注意
      1. Fragment的onCreateView()方法返回FragmentUI布局，inflate()第三个参数要为false，因为Fragment内部实现中，会把该布局添加到container中，如果设置为true那会就会重复添加，会异常
      2. 创建Fragment时要传参数的话，必须通过setArguments(Bundle)添加，不建议通过Fragment带参构造函数，内存紧张被杀死恢复时能保留。在onAttach()中通过getArgumens()来获取。
      3. 获取Activity对象不建议getActivity()，而是在onAttach()中将Context强转为Activity对象
      4. 支持回退栈addToBackStack(null)，remove时如果被移除的Fragment没添加到回退栈，那么这个实例就会被销毁
      5. commit要在Activity.onSaceInstance()之前调用，即onPause时
   5. 数据传递：
      1. Fragment-Activity：回调接口，onAttach时，把activity给到接口变量
      2. Activity-Fragment：fragment.setArguments(bundle)，getArguments()
5. 怎么启动service，service和activity怎么进行数据交互
   1. 答：startService，bindService
      1. startService：startService(Intent) ；onCreate，onStartCommand，onDestory，生命周期和开启者activity独立，开启者不能调用service中的方法
      2. bindService：bindService(Intent, ServiceConnection, int) ；onCreate，onBind，中间有开启者的ServiceConnection对应方法执行，onUnbind，onDestory，生命周期和开启者activity绑定，onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法
      3. 先stop无反应，调用unbindService时才能销毁Service；先unbindService只能onUnbind不能销毁，调用stopService时才可销毁
      4. onStartCommand会多次执行，但是onBind只执行一次
   2. 答：
      1. 广播：startService后，在service中发出广播，activity接收处理。自定义广播所以会有延迟且广播中不能执行耗时操作
      2. 接口
      3. 第三方框架EventBus
      4. Handler
      5. Service中onBind返回自定义的。Activity中通过ServiceConnect拿到onBind返回的binder对象进行操作自定义Bind的方法
      6. Binder Service后使用Messager信使，原理和上面相似也是通过onBind返回一个由Handler构建的Messenger，在Activity中拿到（这个就是Service端的Messenger），Activity中封装Activity端的Messenger和msg，再通过ServiceMessenger发送。处理是Messenger的Handler处理，一般用HandlerThread。
      7. sharedpreferrence：并发时不可靠
6. 启动模式，启动其他APP的模式，一个activity启动另外一个activity的生命周期
7. 字节流和字符流说一下
   1. 字节：Byte=8bit；一个字节是8位，只能有256个值，如果用来表示文字，可以表示ASCII码。但中文有几千个汉字，所以一个字节表示不了，所以就有两个字节，编码方案有GB2312，GBK等
   2. 字符集把所有常用语言都容纳进来，1字节放不下，Java使用Unicode，用char这个数据类型表示一个多字节的字符
   3. 综上：
      1. 字节流就是普通的二进制流，读出来的是bit
      2. 字符流就是在字节流的基础上按照字符编码处理，处理的是char，即字节->编码->字符
8. GET和POST区别说一下
   1. 区别：对数据无副作用，幂等（是否可刷新，收藏），可以缓存，安全性（放Url/Body），编码
      1. 本质上都是TCP链接，并无差别。但由于HTTP规定和浏览器服务器的限制，导致在应用中有些不同。GET产生一个TCP数据包http header和data同时发，POST两个先发header服务端响应后再发data。
9. 重载和重写区别
   1. 重载：是方法之间的多态性，调用方法时传递不同参数个数和参数类型
   2. 重写：父类子类之间的多态性，对父类函数的重写，需要父类函数，可以显示调用super
10. 热更新原理
11. APK文件里面都有些什么
12. Android程序运行时使用的是普通的JVM吗(ART的优化点)
    1. 所有class优化合并为一个class.dex（65535问题-MultiDex），安装执行中再优化为odex（对齐操作，去重）
    2. jvm基于栈，art基于寄存器，字节码指令变长但是行数减少，增加了速度
    3. 对堆的管理，划分为两部分，防止频繁创建
13. 图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM，Bitmap图片优化
14. listview图片加载错乱的原理和解决方案，listview是如何做缓存的？
15. Android 打包过程经历了什么
16. 序列化知道吗，说一下为什么要序列化
    1. Java对象保存为二进制字节码，数据格式的转化，网络传输时可序列化为json文件
    2. 对象通过网络进行传输时，因为数据只能够以二进制的形式在网上传输，所以需要先序列化转为二进制，接收端读取到再反序列化
    3. serialVersionUID是用来辅助对象的序列化反序列化的，显示定义，JVM自动生成的比较敏感
17. stringbuilder  和stringbuffer区别
    1. string中的char数组是final的所以不可变，每次都得new效率低，相当于生成新的String然后改变指针
    2. StringBuffer，可变，线程安全，加个sync，有缓冲超过时自动扩容
    3. StringBuilder，可变，非线程安全，速度更快
18. Android的Service的生命周期有两种启动方法，有什么区别
    1. 答：见上面
19. 请介绍下activty的加载过程
    1. 答：Activity——AMS——ApplicationThread——AMS——ApplicationThread
20. 解析Json,除了Json还有哪些数据传输格式,Json解析的时候是怎么将json解析为对应的类
    1. 答：XML
    2. 答：GSON将Java对象和JSON数据之间进行映射，使JSON字符串转化成一个JAVA对象
21. Dalvik和Art虚拟机区别
    1. 答：Dalvik只会执行.dex文件，会先将.dex转化成可运行的机器码，又因为65535，导致冷启动时需要合包，所以APP启动慢
    2. 答：ART在按照APK时直接将dex处理成可直接运行的.oat文件，ART支持多dex，所以不会有合包的过程，会提升速度

# 线程

## Handler

1. 一个线程是否只有一个Looper；如何保证一个线程只有一个Looper（Handler和ThreadLocal两面）
   1. 答：是的。Looper.prepare()中会先通过sThreadLocal.get()来获取判断，有的话会抛异常；而且如果主线程的话还会在判断一次是否有mainLooper
2. Handler如何实现子线程和主线程通信
   1. 答：使用不同的Looper就好。Handler发出去的msg都在对应Looper所在的线程中执行。这里提一下（Threadhandler）
   2. 虽然是由handler处理的消息(target.dispatch)但是过程是在looper的loop中的，所以handmsg和looper一个线程
3. handler原理，是如何实现延时的
   1. 答：1.queue.enqueueMessage会按照时间排序msg，2.looper.next拿消息时会判断当前时间和msg时间，3.native的阻塞唤醒机制，除非时间到了或者有新消息插入到队首时才会唤醒
4. Handler.postDelayed原理，内部怎么实现，阻塞后为什么不会ANR
   1. 答：同上，native的阻塞唤醒机制
5. handler发消息给子线程，looper怎么启动
   1. 答：HandlerThread中，run()时，Looper会prepare（有则报错，无则生成一个Looper并设置给ThreadLocal）并调用loop()开启loop。只需要新建Handler传入这个线程的Looper就好
6. AsyncTask和Handler+Thread机制的区别
   1. 答：Async方式只能严格按照定义好的流程走，Thread+Handler更灵活。频繁更新UI如进度显示，可以用Async，可以避免多发消息。Async更轻量

## 多线程

1. 主线程是何时初始化的ActivityThread
   1. activity启动流程

2. 多线程的方式有哪些，怎么实现多线程，多线程通信方式，什么是线程不安全的
   1. 答：继承Thread类；实现Runnable接口（new Thread(Runnable))；实现Callable接口（new FutureTask<>(callableDemo)，再给Thread。有返回值）；线程池。四种方式
   2. 答：通信方式：AsyncTask，Handler，ThreadHandler+Handler，IntentService（Handler+HandlerThread）
   3. 答：CPU指令重排+workMemory（CPU缓存）引起的，解决——happens-before原则

3. 线程间切换的方法，线程启动的方式
   1. 答：AsyncTask，Handler
   2. 答：start，ThreadPool.execute/submit，submit有返回值（同Callable和Runnable区别）

4. 死锁的条件，如何破坏死锁
   1. 答：竞争不可抢占资源引起死锁；进程/线程推进不当引起死锁；都可以归结为竞争/等待资源造成的僵局
      1. 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
      2. 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
      3. 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
      4. 环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链
   2. 答：加锁顺序，加锁时限，死锁检测

5. synchronized与volatile，synchronized锁住对象的理解，static synchronized
   1. 首先需要理解线程安全的两个方面：执行控制和内存可见
      1. 执行控制：目的是控制代码执行顺序以及是否可以并发执行
      2. 内存可见：控制的是执行结果在内存中对其他线程的可见性，Java内存模型中，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完后在刷回去
   2. synchronized：解决的是执行控制的问题，它会阻止其他线程获取当前对象的监控锁，这样就使得当前对象被sync保护的代码块无法被其他线程访问，也就无法并发执行，更重要的是sync还会创建一个内存屏障，保证了所有CPU操作结果都会直接刷到主存中，从而保证了这个操作的可见性，同时也使得先获得这个锁的线程的所有操作happens-before随后获得这个锁的线程的操作
   3. volatile：解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序无要求的需求
   4. volatile只能实现对原始变量操作的原子性，不能保证符合操作原子性，即使只是i++，它也是多个原子操作组成的。只有满足这两个条件才能使用：1.对变量的写入操作不依赖变量的当前值，或者能保证只有单个线程更新变量值；2.该变量没有包含在其他变量的不变式中
   5. 区别：
      1. volatile本质是告诉JVM当前变量在workmemory中的值是不确定的，需要从主存中读取；sync是锁定当前变量，只有当前可访问，其他线程被阻塞
      2. volatile仅能用在变量级别，sync是变量，方法，类
      3. volatile不会造成线程阻塞，sync会
      4. volatile不会被编译器优化，sync会（优化锁：轻量级锁，重量级，锁自旋等）
   6. 一个锁的是类对象，一个锁的是实例对象；若类对象被lock，则类对象的所有同步方法全被lock；若实例对象被lock，则该实例对象的所有同步方法全被lock；其中synchronized（this） 更灵活和object加锁没区别。

6. 线程里面sleep和wait什么区别（从方法所属类，调用的效果，是否释放锁答的）
   1. 答：
      1. Sleep：属于Thread类，让当前线程停止执行，阻塞，把CPU让给其他线程执行，但不会释放对象锁，到指定时间后线程又会自动恢复到可运行状态（不能保证睡眠到期后就开始执行）；休眠状态时interrupt会抛出异常然后自行去处理做收尾
      2. wait()/notify()：属于Object类，会释放锁并交出CPU执行权限，进入等待此对象的等待锁定池。ThreadA调用Obj.wait。A就会停止运行转化为阻塞状态，等待时间就看其他线程是否调用Obj.notify了。必须包含在Synchronzied语句中。notify后另一个线程不会立刻执行，要等这边的代码执行完
      3. join()：暂停当前线程，等待被调用线程指向结束之后再继续执行。主线程需要在子线程执行之后再结束，就需要用到join()；t.start();t.join()；当线程调用join后，main线程进入等待，等t执行完后再继续执行，底层是wait()
      4. yield()：让当前线程交出CPU权限，让CPU去执行其他线程。和sleep类似，同样不会释放锁。但yield不能控制具体的交出CPU时间，且只能让同优先级的线程有获取CPU的机会。不会进入阻塞而是线程重回就绪状态，只需等待重新CPU时间片段，这里和sleep不同
      5. interrupt：使得处于阻塞状态的线程抛出一个异常，即可以中断一个正处于阻塞状态的线程。相当于将中断标志置为true，可以通过isInterrupt来中断正在运行的线程。但一般不建议，可以采用while循环+标志位的方式

7. sleep不释放锁和wait释放锁，底层怎么做的

   1. wait，对象头中的Monitor相关操作，当多线程同时访问一段同步代码时，首先会进入EntryList 队列中，当某个线程通过竞争获取到对象的monitor后，monitor 会把 owner变量设置为当前线程，同时monitor中的计数器 count 加 1，即获得对象锁。若持有 monitor 的线程调用 wait() 方法，将释放当前持有的 monitor，owner 变量恢复为 null，count 自减 1，同时该线程进入 WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor（锁）并复位变量的值，以便其他线程进入获取 monitor（锁）

8. 多线程断点续传原理

9. 线程如何按顺序执行，怎么停止一个线程
   1. 答：
      1. join（底层是wait，阻塞主线程，然后再执行子线程）
      2. 单线程的线程池（但不建议用）
      3. ReentrantLock(true)公平锁；CountDownLatch；CyclicBarrier 
         1. CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行 ，重点是那个**“一个线程”**, 是它在等待， 而另外那N的线程在把**“某个事情”**做完之后可以继续等待，可以终止。CountDownLatch 是计数器, 线程完成一个就记一个, 就像 报数一样, 只不过是递减的 
         2. CyclicBarrier        : N个线程相互等待，任何一个线程没有到达或完成时，所有的线程都必须互相等待 ，重点是那**N个线程**，他们之间任何一个没有完成，所有的线程都必须等待，CyclicBarrier更像一个水闸, 线程执行就想水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开始泄流 
   2. 答：while循环+标志位；interrupt（interrupt只是修改线程interrupt标志位，然后让线程自行去读取判断操作）return

10. 线程池描述

11. sleep,wait,yield在多线程应用中的区别，线程协同工作

12. synchronized和Lock的区别
    1. 存在层次：sync是Java关键字；Lock是一个类
    2. 锁的释放：sync执行完或发生异常，jvm会自动释放；Lock必须手动在finally中释放
    3. 锁的状态：无法判断；可以判断isInterrupt
    4. 锁类型：可重入，不可中断，非公平；可重入，可中断(interrupt)，可公平；可重入最大作用是避免死锁。否则子类同步方法调用父类同步方法会发生死锁
    5. Lock可以提高多线程读操作效率（读写锁，读写操作分离）
    6. 资源竞争不激烈两者差不多，非常激烈（大量线程同时竞争），此时Lock性能高于sync（sync很重，这里可以引出jvm的线程优化，锁自旋，轻量锁，偏向锁，锁粗化）
    7. 性能区别：
       1. sync原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转化线程阻塞时会引起线程上下文切换，很多线程竞争锁时，会引起CPU频繁切换导致效率很低
       2. Lock用的是乐观锁。乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（compare and swap）
       3. 进一步看ReentrantLock源码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。CPU提供了指令可以自动更新共享数据，而且能够检测到其他线程的干扰，而compareAndSet()就用这些代替了锁定。这称为非阻塞算法，意思是一个线程的失败或挂起不应该影响其他线程的失败或挂起。
       4. sync的原理就得从对象头中的Monitor说起，再提一下JVM对sync的优化
       5. lock原理，从ReentrantLock相关的AQS机制说起

    ### 总结：

    1. Thread状态：
       1. 就绪：start()，sleep()休眠超时时进入
       2. 阻塞：调用sleep()，wait()，join()进入
       3. 运行：调用run()，notify()，notifyAll()进入
       4. 死亡：run()执行完成进入
    2. CAS：
       1. CompareAndSwap，比较并替换。CAS中有三个基本操作数：内存地址V，旧的预期值A，要修改的新值B
       2. sync属于悲观锁，悲观的认为并发情况很严重，所以严防死守，CAS是乐观锁，认为没那么严重所以让线程不断去重试更新
       3. 除了Automic类还有Lock系列类的底层，甚至1.8之后优化过的sync在转变为重量级锁之前，也会采用CAS机制
       4. 缺点：返回循环CPU开销大；ABA问题（解决方案是加版本号-AtomicStampedReference类）

# 集合框架

1. copyonwritelist/copyonwriteset
   1. 答：ArrayList的线程安全的变体，其中所有可变操作(add,set)都是通过对底层数组进行一次新的复制来实现；内部是ReentrantLock和一个volatile的数组；List大小通常很小，只读操作远多于可变操作
   2. 答：copyonwriteset是线程安全的无序集合，可以理解为线程安全的HashSet。但HashSet是通过散列表(HashMap)实现的，而copyonwriteset是通过“动态数组”copyonwritelist实现的。因为是复制操作所以可变操作的开销很大。迭代器不支持remove()。copyonwritelist数组可以有重复，但copyonwriteset 是集合不能有重复。因此copyonwritelist 额外提供了addIfsent()和addAllsent()两个API来添加元素
   3. 需要copy数组的原因：Volatile的数组只针对数组的引用具有volatile语义，而不是它的元素。读操作是没有同步处理的，读写操作是分离的，写操作会加锁，可变操作都是在新数组中进行，所以保证了正常读而不被阻塞；新的数组修改完copy给原volatile数组时，根据volatile语义，此时再去读就是新的数组
2. List、Set、Map，Hashmap/Hashtable/ConcurrentHashmap
   1. List：元素有序可重复，ArrayList/LinkedList都是线程不安全，
   2. Set：元素无序不可重复
   3. Map：键值对方式存储
   4. Hash：
      1. HashMap：不是线程安全能存Null，要安全的话要用ConcurrentHashmap
      2. HashTable：散列表/哈希表，根据key-value直接进行访问的数据结构，映射函数叫散列函数，存放数据的数组叫散列表。线程安全的，每个方法都加了sync，单链表
      3. HashSet：在HashSet中放入数据，首先通过hasCode()方法计算它们的哈希值，根据哈希值取模运算后，依次放入。在放入时，有重复的(上面计算出的哈希值)，则需要另外的方法equals()来判断是否相等，相等(重复)就不放入。基础类型时Java帮我们写了hasCode()和equals()所以才能体现出hashSet特点。放入自定义Bean时，就需要自己写。
      4. LinkedHashSet：继承自HashSet，有序，唯一，效率高
3. 线程安全和不安全的集合有哪些
   1. 线程安全的集合：CopyOnWriteList，CopyOnWriteSet，HashTable，ConcurrentHashMap，Vector，Properties，
   2. 非线程安全的集合：ArrayList/LinkedList，HashSet，TreeSet，HashMap，TreeMap
4. hashset怎么添加元素，hashcode ，equals，toString又是什么
   1. 答：HashSet的add()通过HashMap的put实现，`map.put(e,null)`放到key的位置
   2. 答：hascode和equals都是用来比较两个对象是否相等。因为重写equals中比较逻辑复杂，这样就效率低；而利用hasCode进行对比只要生成一个hash值就好，效率高。为啥还要有它，是因为hashCode不可靠，会有一样的，生成的算法有问题，不是绝对可靠，所以先用hashCode比，hascode不同那两对象肯定不同，hascode相同则再对比equals。（这里可以举例HashSet方基础类型数据和自定义Bean的不同现象）
   3. 答：toString()复写：序列化：1.想把内存中的对象状态保存到一个文件中或数据库中的时候；2.想把对象通过网络进行传播的时候
5. HashMap的hash值和Object的hashcode()什么关系
   1. 答：HashMap的hash值就是在hash表中有对应的位置，也就是key。通过算法生成（地址-》整数-》hash算法-》hashcode）。主要是为了查找的快捷性，用于在散列存储结构中确定对象的存储地址（用hashcode来代表对象在hash表中的位置）。存在的意义就是要在HashMap（HashSet其实就是HashMap）中使用，HashMap之所以快是因为用的散列表，根据Key的hascode值生成数组下标（通过内存地址直接查找，不需要判断，但是需要内存，属于用空间换时间）
   2. hasCode()是哈希函数，生成hascode
6. HashMap实现原理，ConcurrentHashMap 的实现原理
   1. HashMap不安全，HashTable全加锁效率低（相当于整个哈希表加了个大锁，读写都不能同时）
   2. ConcurrentHashMap：
      1. 1.7之前使用锁分段技术，将数据分成一段一段的存储Segment(Segment类就是一个小的HashMap继承了ReentrantLock)，然后给每一段数据分配一把锁，其他部分不受影响。需要跨段操作时需要按顺序锁定所有段，操作完后又按顺序释放。
      2. 1.8取消了Segment直接采用table[] 保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，并发控制使用sync和CAS来操作。并且大于8小于64时会扩容，大于64时，会将该节点的链表转换为红黑树。
7. HashMap HashTable的区别
   1. 答：在总结中已回答，如下
8. ArrayList是怎么扩容的知道吗
   1. 扩容：把原来数组复制到另一个内存空间更大的数组中
   2. 添加元素：把新元素添加到以后的数组中
   3. 步骤：
      1. add方法，第一步先确定容量。
         1. 如果数组是空的，直接给一个10的length。否则+1
         2. 当需要长度大于原来长度时就需要扩容了，oldCapacity >> 1，右移，即原来长度的一般，结果就是1.5，即每次扩容是原来的1.5倍

### 总结：

1. HashMap：根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，速度快，但遍历顺序是不确定的。值可以为Null。是非线程安全的，多线程下进行put会引起死循环导致CPU利用率100%，需要线程安全可使用ConcurrentHashMap。1.8后存储结构为数组+链表+红黑树。
2. HashTable：和HashMap类似，区别是HashTable不允许key和value为null且HashTable线程安全。任意一时间只有一个线程能读写HashTable，其他线程只能阻塞，相当于整张表加锁，并发性能不如ConcurrentHashMap(分段锁)。不建议使用，应该换成HashMap或ConcurrentHashMap。
3. ConcurrentHashMap：全局加锁改为局部加锁。
   1. 1.7原理：数组+Segment+分段锁。Segment类似HashMap结构，内部有一个Entry数组，数组中每个元素又是一个链表同时又是一个ReentrantLock（Segment继承ReentrantLock）用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，一个线程占用锁访问其中一段数据时，其他段数据也能被其他线程访问。定位一个元素需要经过俩次Hash操作：1.定位到Segment2.定位到元素所在的链表头部。缺点是Hash过程长
   2. 1.8原理：参考了1.8的HashMap，采用了数组+链表+红黑树实现。内部大量采用CAS，放弃了Segment而使用Node。线程安全实现方式是Sync+CAS
4. LinkedHashMap：是HashMap的一个子类，保存了记录插入顺序
5. TreeMap：实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键的升序，也可以指定比较器。

### 并发容器：

1. ConcurrentHashMap：代替HashTable，sync的HashMap，1.7Segment分段，1.8CAS无锁
2. CopyOnWriteArrayList：代替ArrayList，Vectory。读多写少。需要复制集合。
3. CopyOnWriteArraySet：代替HashSet。基于CopyOnWriteArrayList，不同的是add时调用的是CopyOnWriteArrayList的addIfAbsent()方法（遍历判断是否有相同）
4. ConcurrentLinkedQueue：不会阻塞的队列，线程安全。对应非并发容器Queue
5. LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue：对应非并发容器是BlockingQueue。实现了可阻塞+线程安全

# 网络

1. Http和Https的区别？
   1. Https是ssl加密传输，Http是明文传输
   2. Https是使用端口443，而Http使用80
   3. HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全
   4. Https协议需要到CA申请证书
2. http状态码
3. Tcp,ip分别属于哪一层
4. tcp三次握手，包括状态的转换
5. udp怎样能够实现可靠传输
6. TCP和UDP区别、哪个效率高，为什么
   1. TCP：传输控制协议，面向连接的，可靠的，基于字节流的传输协议，位于传输层。特点是：慢启动，阻塞控制，快速重传，可恢复
   2. UDP：用户数据报协议，也是传输层协议，与TCP比较，UDP是一种不可靠的数据交付，不保证数据是否到达目标节点。是一种无连接的协议，传输的两端无需建立连接，不对数据报进行检查与修改，无需等待对方应答，会出现分组丢失，乱序，重复等现象。但具有较好的实时性，效率
7. UDP，丢包了应该怎么处理
   1. UDP包过大：增加系统发送或接受的缓冲区大小
   2. 发包速率过快：增加应答机制，处理完一个包后，再继续发
   3. 接收数据后处理太慢：用两个线程，分别处理接受和发送，本质还是增大缓冲区大小
   4. 重发机制和超时机制
8. Socket 创建流程

# Retrofit

## 优点

1. 解耦，请求速度快，使用方便
2. 可以配置不同HttpClient来实现网络请求（OKHttp，HTTPClient）
3. 支持同步，异步和RXJava
4. 可以配置不同的反序列化工具来解析数据，json，xml