# JAVA
1. GC算法，垃圾搜集算法有哪些
2. GC（GC回收时机，如何GC回收，标记了的立刻会被回收吗）
3. 你怎么判断对象是gc roots对象
4. 垃圾回收机制，有什么代，用什么策略
5. java finalize用来干啥,gc都系统做了，为什么还有finalize这个方法
6. JVM内存模型？性能调优？
7. 内部类相比继承有什么优势？
8. static
9. 反射机制
10. 四大引用，java引用类型（强 软 弱 虚）
11. jvm内存区域
12. JVM的gc什么机制（GC roots可达性）
13. 内部类能访问外部的变量和方法吗
14. 多态
15. classloader类加载机制，双亲委派模型
16. 内部类和静态内部类和匿名内部类
17. 单例和静态变量，静态方法的区别
18. 比较两个对象怎么比较，equals，== ；==和equals区别，重写equals怎么写,hashcode作用
19. 单例模式

# Android

1. ThreadLocal 原理
2. 四大组件
3. Activity的加载模式 standard，singleTop，singleTask，singleInstance
4. Activity，Fragment（fragment添加的方法，生命周期），Fragment比Activity的优点
5. 怎么启动service，service和activity怎么进行数据交互
6. 启动模式，启动其他APP的模式，一个activity启动另外一个activity的生命周期
7. 字节流和字符流说一下
8. GET和POST区别说一下
9. 重载和重写区别
10. 热更新原理
11. APK文件里面都有些什么
12. Android程序运行时使用的是普通的JVM吗(ART的优化点)
13. 图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM，Bitmap图片优化
14. listview图片加载错乱的原理和解决方案，listview是如何做缓存的？
15. Android 打包过程经历了什么
16. 序列化知道吗，说一下为什么要序列化
17. stringbuilder  和stringbuffer区别
18. Android的Service的生命周期有两种启动方法，有什么区别
19. 请介绍下activty的加载过程
20. 解析Json,除了Json还有哪些数据传输格式,Json解析的时候是怎么将json解析为对应的类
21. Dalvik和Art虚拟机区别

# 线程

## Handler

1. 一个线程是否只有一个Looper；如何保证一个线程只有一个Looper（Handler和ThreadLocal两面）
   1. 答：是的。Looper.prepare()中会先通过sThreadLocal.get()来获取判断，有的话会抛异常；而且如果主线程的话还会在判断一次是否有mainLooper
2. Handler如何实现子线程和主线程通信
   1. 答：使用不同的Looper就好。Handler发出去的msg都在对应Looper所在的线程中执行
3. handler原理，是如何实现延时的
   1. 答：1.queue.enqueueMessage会按照时间排序msg，2.looper.next拿消息时会判断当前时间和msg时间，3.native的阻塞唤醒机制，除非时间到了或者有新消息插入到队首时才会唤醒
4. Handler.postDelayed原理，内部怎么实现，阻塞后为什么不会ANR
   1. 答：同上，native的阻塞唤醒机制
5. handler发消息给子线程，looper怎么启动
   1. 答：HandlerThread中，run()时，Looper会prepare并开启loop。只需要新建Handler传入这个线程的Looper就好
6. AsyncTask和Handler+Thread机制的区别
   1. 答：Async方式只能严格按照定义好的流程走，Thread+Handler更灵活。频繁更新UI如进度显示，可以用Async，可以避免多发消息。Async更轻量

## 多线程

1. 主线程是何时初始化的ActivityThread
   1. activity启动流程
2. 多线程的方式有哪些，怎么实现多线程，多线程通信方式，什么是线程不安全的
   1. 答：继承Thread类；实现Runnable接口（new Thread(Runnable))；实现Callable接口（new FutureTask<>(callableDemo)，再给Thread。有返回值）；线程池。四种方式
   2. 答：通信方式：AsyncTask，Handler，ThreadHandler+Handler，IntentService（Handler+HandlerThread）
   3. 答：时序问题+workMemory（CPU缓存）引起的，解决——happens-before原则
3. 线程间切换的方法，线程启动的方式
   1. 答：AsyncTask，Handler
   2. 答：start，ThreadPool.execute/submit，submit有返回值（同Callable和Runnable区别）
4. 死锁的条件，如何破坏死锁
   1. 答：竞争不可抢占资源引起死锁；进程/线程推进不当引起死锁；都可以归结为竞争/等待资源造成的僵局
      1. 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
      2. 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
      3. 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
      4. 环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链
   2. 答：加锁顺序，加锁时限，死锁检测
5. synchronized与volatile，synchronized锁住对象的理解，static synchronized
   1. 首先需要理解线程安全的两个方面：执行控制和内存可见
      1. 执行控制：目的是控制代码执行顺序以及是否可以并发执行
      2. 内存可见：控制的是执行结果在内存中对其他线程的可见性，Java内存模型中，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完后在刷回去
   2. synchronized：解决的是执行控制的问题，它会阻止其他线程获取当前对象的监控锁，这样就使得当前对象被sync保护的代码块无法被其他线程访问，也就无法并发执行，更重要的是sync还会创建一个内存屏障，保证了所有CPU操作结果都会直接刷到主存中，从而保证了这个操作的可见性，同时也使得先获得这个锁的线程的所有操作happens-before随后获得这个锁的线程的操作
   3. volatile：解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序无要求的需求
   4. volatile只能实现对原始变量操作的原子性，不能保证符合操作原子性，即使只是i++，它也是多个原子操作组成的。只有满足这两个条件才能使用：1.对变量的写入操作不依赖变量的当前值，或者能保证只有单个线程更新变量值；2.该变量没有包含在其他变量的不变式中
   5. 区别：
      1. volatile本质是告诉JVM当前变量在workmemory中的值是不确定的，需要从主存中读取；sync是锁定当前变量，只有当前可访问，其他线程被阻塞
      2. volatile仅能用在变量级别，sync是变量，方法，类
      3. volatile不会造成线程阻塞，sync会
      4. volatile不会被编译器优化，sync会（优化锁：轻量级锁，重量级，锁自旋等）
   6. 一个锁的是类对象，一个锁的是实例对象；若类对象被lock，则类对象的所有同步方法全被lock；若实例对象被lock，则该实例对象的所有同步方法全被lock；其中synchronized（this） 更灵活和object加锁没区别。
6. 线程里面sleep和wait什么区别（从方法所属类，调用的效果，是否释放锁答的）
   1. 答：
      1. Sleep：属于Thread类，让当前线程停止执行，阻塞，把CPU让给其他线程执行，但不会释放对象锁，到指定时间后线程又会自动恢复到可运行状态（不能保证睡眠到期后就开始执行）；休眠状态时interrupt会抛出异常然后自行去处理做收尾
      2. wait()/notify()：属于Object类，会释放锁并交出CPU执行权限，进入等待此对象的等待锁定池。ThreadA调用Obj.wait。A就会停止运行转化为阻塞状态，等待时间就看其他线程是否调用Obj.notify了。必须包含在Synchronzied语句中。notify后另一个线程不会立刻执行，要等这边的代码执行完
      3. join()：主线程需要在子线程执行之后再结束，就需要用到join()；t.start();t.join()；当线程调用join后，main线程进入等待，等t执行完后再继续执行，底层是wait()
      4. yield()：让当前线程交出CPU权限，让CPU去执行其他线程。和sleep类似，同样不会释放锁。但yield不能控制具体的交出CPU时间，且只能让同优先级的线程有获取CPU的机会。不会进入阻塞而是线程重回就绪状态，只需等待重新CPU时间片段，这里和sleep不同
      5. interrupt：使得处于阻塞状态的线程抛出一个异常，即可以中断一个正处于阻塞状态的线程。相当于将中断标志置为true，可以通过isInterrupt来中断正在运行的线程。但一般不建议，可以采用while循环+标志位的方式
7. sleep不释放锁和wait释放锁，底层怎么做的
8. 多线程断点续传原理
9. 线程如何按顺序执行，怎么停止一个线程
   1. 答：join（底层是wait，阻塞主线程，然后再执行子线程）；单线程的线程池（但不建议用），ReentrantLock(true)公平锁；CountDownLatch；CyclicBarrier 
      1. CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行 ，重点是那个**“一个线程”**, 是它在等待， 而另外那N的线程在把**“某个事情”**做完之后可以继续等待，可以终止。CountDownLatch 是计数器, 线程完成一个就记一个, 就像 报数一样, 只不过是递减的 
      2. CyclicBarrier        : N个线程相互等待，任何一个线程没有到达或完成时，所有的线程都必须互相等待 ，重点是那**N个线程**，他们之间任何一个没有完成，所有的线程都必须等待，CyclicBarrier更像一个水闸, 线程执行就想水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开始泄流 
   2. 答：while循环+标志位；interrupt（interrupt只是修改线程interrupt标志位，然后让线程自行去读取判断操作）return
10. 线程池描述
11. sleep,wait,yield在多线程应用中的区别，线程协同工作
12. synchronized和Lock的区别
    1. 存在层次：sync是Java关键字；Lock是一个类
    2. 锁的释放：sync执行完或发生异常，jvm会自动释放；手动在finally中释放
    3. 锁的获取：

# 集合框架

1. copyonwritelist
2. List、Set、Map，Hashmap/Hashtable/ConcurrentHashmap
3. 线程安全和不安全的集合有哪些
4. hashset怎么添加元素hashcode equals
5. HashMap的hash值和Object的hashcode()什么关系
6. HashMap实现原理，ConcurrentHashMap 的实现原理
7. HashMap HashTable的区别
8. ArrayList是怎么扩容的知道吗

# 网络

1. Http和Https的区别？
   1. Https是ssl加密传输，Http是明文传输
   2. Https是使用端口443，而Http使用80
   3. HttpsSSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比Http协议安全
   4. Https协议需要到CA申请证书

2. http状态码
3. Tcp,ip分别属于哪一层
4. tcp三次握手，包括状态的转换
5. udp怎样能够实现可靠传输
6. HTTP和HTTPS有什么区别，SSL是怎样实现安全传输（具体过程、对称非对称）
7. TCP和UDP区别、哪个效率高，为什么
8. UDP，丢包了应该怎么处理
9. Socket 创建流程